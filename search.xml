<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hadoop 伪分布式环境搭建]]></title>
    <url>%2F2018%2F05%2F02%2FHadoop-%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hadoop伪分布式安装步骤JDK 安装（1.8版本及以上） 貌似如果JDK是1.7的话会遇到一些莫名的BUG…比如编译Spark的时候就卡了很久！！ 解压： tar -zxvf jdk-7u79-linux-x64.tar.gz -C ~/app添加到环境变量：~/.bash_profile export JAVA_HOME=/home/hadoop/app/jdk1.7.0_79 export PATH=$JAVA_HOME/bin:$PATH 使得环境变量生效： source ~/.bash_profile验证Java是否配置成功： java -version 安装sshsudo yum install ssh 配置免密码登录 ssh-keygen -t rsa ==&gt; 会生成密码文件到 /home/hadoop/.ssh/id_rsa 中 cp ~/.ssh/id_rsa.pub ~/.ssh/authorized_k eys ==&gt; 将生成的rsa密钥添加到认证密钥中 下载并解压hadoop下载：直接去cdh网站下载 ==&gt; http://archive.cloudera.com/cdh5/cdh/5/ 解压： tar -zxvf hadoop-2.6.0-cdh5.7.0.tar.gz -C /usr/local //将 hadoop 文件夹解压到 /usr/locla 文件夹下 配置文件的修改（hadoop_home/etc/hadoop）hadoop-env.sh 文件中修改： export JAVA_HOME=/usr/local/jdk1.7.0_80 core-site.xml 文件中添加： &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs:// localhost:8020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/hadoop/tmp&lt;/value&gt; &lt;/property&gt; 注：hadoop2.X 版本 将端口从 9000 改为 8020 hdfs-site.xml 文件中添加： &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; 注：只有一个结点，所以副本设置为1 slaves : 有多少个集群，就将主机名添加到slaves 中 启动 HDFS格式化文件系统（仅第一次执行即可，不要重复执行）：./hadoop namenode -format 也可以配置hadoop环境变量之后直接执行： hadoop namenode -format启动hdfs： sbin/start-dfs.sh 验证是否启动成功： jps DataNode SecondaryNameNode NameNode 浏览器访问方式： http://ip:50070 停止 HDFSsbin/stop-dfs.sh 启动Hadoop HDFS 而DataNode 无法启动的问题可能是之前执行 format 操作之后 导致 DataNode 和 NameNode 的 clusterID不一样&emsp;解决方法：&emsp;1. 进入 Hadoop 中 core-site.xml 文件中配置的Hadoop 文件存放路径，即 hadoop.tmp.dir&emsp;2. 进入 dfs 文件中，将 data 文件夹中 VERSION 文件中的 clusterID 改为 name文件夹中 VERSION文件中的 clusterID]]></content>
  </entry>
  <entry>
    <title><![CDATA[科学上网教程]]></title>
    <url>%2F2018%2F04%2F23%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[科学上网教程 让我们开始愉快的墙外之旅吧~ 注册 Vultr网站进入 https://www.vultr.com/ 进行注册 具体的注册细节就不细说了 注意！！最近新用户注册会赠送 $25 哟~~ 进入 https://www.vultr.com/ 进行注册 这样就注册成功了 选择左侧栏的 Billing 进入左侧栏的 Servers 选择相应配置 继续配置 这样就配置好了，然后进入详情记录ip地址、root密码等相关属性 使用XShell连接服务器我们这里使用 XShell 连接我们配置好的远程服务器( XShell 使用方法就不赘述了)输入之前的 ip、root 密码等属性，登录远程服务器 锐速更换内核 输入命令： 1**rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm** 然后输入命令： rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm —force 最后重启服务器： reboot 安装锐速 输入命令：wget -N —no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 选择 14 其他功能 配置锐速 选择安装锐速 安装成功 安装libsodium(chacha20) 选择 4 安装libsodium 输入 y 安装成功 安装ShadowSocksR 选择 1 安装ShadowSocksR 配置ShadowSocksR加密方式： 15. chacha20协议插件： 4. auth_aes128_shal混淆插件： 5. tlsl.2_ticket_auth 这里输入 y 之后就连续敲三个回车 漫长等待之后，离成功就差一点点了复制这里的SSR二维码，后面会用到 PC端配置 PC端我们使用 ShadowsocksR 进行墙外之旅这里下载ShadowsocksR文件 链接：https://pan.baidu.com/s/1_APq2fDzB0hUKS5sbSbY4Q密码：e4j8 使用其中的 ShadowsocksR-dotnet4.0.exe 文件 运行后在隐藏图标中找到这个小飞机然后右键点击，选择 粘贴板批量导入ssr://连接… 选择我们配置的服务器，点击确定就可以享受愉快的墙外之旅啦~ 大功告成！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Hashcode以及相关知识]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%85%B3%E4%BA%8EHashcode%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[有关HashCode以及相关知识 今天看了一些有关HashCode的博文，将网上相关的知识整理之后分享一下。 HashCode什么是HashCode HashCode 也即哈希码，是 Java对象 的一个特征码，用它来区分两个Java对象是否相同。HashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 为什么要用HashCode 因为散列集合中不允许存在重复对象，当向集合中插入对象时，需要判别在集合中是否已经存在该对象，那么这个时候就需要用到HashCode。 便于实现 散列存储。 散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的，而不像在数组中的遍历过程，采用存储数组中内容的部分元素作为映射函数的输入，映射函数的输出就是存储数据的位置，这样的访问速度就省去了遍历数组的实现，因此时间复杂度可以认为为O(1)，而数组遍历的时间复杂度为O(n)。 ——-[百度百科] 以HashMap为例先提一下 HashMap 中的indexFor()方法：123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; indexFor()方法用于返回插入数据的位置。普通的Hash打散的算法都是mod表的长度，比如h%length,但是 HashMap 却用的是位运算。 因为 HashMap 的初始大小和扩容都是以2的次方来进行的，换句话说length-1换成二进制永远是全部为1，比如 length 为16，则 length-1 为 1111. 而我们知道，任何一个数与它对应的二进制位数上全为1的二进制数进行与运算就是它本身。（例：1001001 ^ 1111111 = 1001001）, 这样保证插入的数据存放在不同的位置，从而最小化哈希冲突，从而实现 散列存储。 再观察 HashMap 中的put()方法：12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125; 其主要思想便是：在键不为空时，根据键对象获取到散列码hash，然后通过散列码得到数组的下标i。在table[i]所表示的 Entry&lt;k,v&gt; 中进行迭代，通过equals()判断该键是否存在，如果存在，则用新的值更新旧的值，返回旧的值；否则将新的键值对添加到 HashMap 中。从这里可以看出，hashCode() 方法的存在是为了减少 equals() 方法的调用次数，从而提高程序效率。 这里我们需要注意到：hashCode() 并不需要总是能够返回唯一的标识码，但是 equals() 方法必须严格地判断两个对象是否相同。 注： 这里贴出的 HashMap 的 put() 方法是网上找的，与我的 jdk1.8 里的内容不一致，但不影响理解。（原因是：JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间）在 jdk1.8 中 **Entry&amp;lt;k,v&amp;gt;** 是 **Node&amp;lt;K,V&amp;gt;** ，原理其实都一样，**Node&amp;lt;K,V&amp;gt;**是一个静态类，有键值对，还有 **hash** 和 **next** 属性。相当于实现了一个链表。 函数里的 table 就是一个 Node&lt;K,V&gt; 数组。有兴趣的同学可以看一看：123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; HashCode的生成 哈希码产生的依据：哈希码并不是完全唯一的，它是一种算法，让同一个类的对象按照自己不同的特征尽量的有不同的哈希码，但不表示不同的对象哈希码完全不同。也有相同的情况，看程序员如何写哈希码的算法。——- [百度百科] 同样以HashMap为例HashMap类中的 hash() 方法:1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 在 Object 类中hashCode() 是一个native方法，意味着方法的实现和硬件平台有关，默认实现和虚拟机有关，对于有些JVM，hashCode()返回的是对象的地址，大多时候JVM根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，并返回。而在 HashMap中，会调用 Key 所属类实现的 hashCode()方法获得 hashCode。 hash() 是一个返回int值的本地方法。当向一个容器(我们假设是HashMap)中插入一个对象时，怎样判断容器中是否已经存在该对象了呢？由于容器中的元素可能成千上万，使用equals()方法依次进行比较是非常低效的。散列的价值在于速度，它将键保存在某处，以便能够很快找到。存储一组元素最快的数据结构是数组，所以使用它来存储键的信息（注意是键的信息，而非键本身）。我们希望在Map中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办呢？ 答案就是：数组不保存键本身，而是通过键对象生成一个数字，将其作为数组的下标，这个数字就是散列码（hashcode），由定义在Object中的、且可能由你的类覆盖的hashCode()方法生成。为解决数组容量被固定的问题，不同的键可以产生相同的下标，这种现象被称为哈希冲突（之前也有说过怎么最小化哈希冲突）。于是，在 HashMap 中查询一个值的过程是：先通过 hash() 计算待插入对象的散列码，然后使用散列码查询数组。对于冲突的处理，常常是通过外部链接，即数组并不直接保存值，而是保存相同 hashCode 的对象链表（之前提到的 Node&lt;K,V&gt;链表），然后依次对链表中的值进行线性查询，这部分查询自然会比较慢。但是，如果散列函数足够好的话，数组的每个位置就只有较少的值。因此，散列机制便可以快速地跳到数组的某个位置，只对很少的元素进行比较。这就是HashMap会如此快的原因。 在Java中，不同的对象有不同的HashCode的生成方法： Object类型 Object类的 hashCode() 返回对象的内存地址经过处理后的结构，由于每个对象的内存地址都不一样，所以哈希码也不一样。 String类型 String类的 hashCode() 根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串所在的堆空间相同，返回的哈希码也相同。 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; 在String类中有 hashCode 的私有字段 12/** Cache the hash code for the string */ private int hash; // Default to 0 在第一次调用hashCode方法时，字符串的哈希值被计算并且赋值给hash字段，之后再调用hashCode方法便可以直接取hash字段返回。 而计String类型计算 hashCode 的方法也比较简单：以31为权重，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。 题外话：为什么要选择31作为权重？ “之所以选择值31是因为它是奇数素数。如果它是偶数，并且乘法溢出，则信息将丢失，因为2的乘法相当于移位。使用素数的优点不太清楚，但它是传统的。31的一个很好的特性是，可以用一个移位和一个减法来代替乘法，以获得更好的性能：31×i =（i &lt; 5）- i。现代VMS自动完成这种优化。” ——-参考Stack Overflow Integer类型Integer类就比较简单了，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100) , i1.hashCode 的值就是100 。由此可见，2个一样大小的Integer对象，返回的哈希码也一样。 HashMap1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 暂时先写到这吧~~后序如果还有补充内容的话会继续更新。如有错误，还请指正。]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2018%2F04%2F22%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[注意！注意！这是第一次文章测试！！ 这是代码测试python 代码 import numpy as np import pandas as pd import matplotlib as plt print(&quot;Hello word!&quot;) Java 代码 System.out.println(&quot;Hello World!&quot;); 这是 MathJax 公式测试\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
</search>
